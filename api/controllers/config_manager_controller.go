package controllers

// package controllers contains code generated from the OpenAPI REST spec. This
// code is generated by the github.com/deepmap/oapi-codegen project. At the time
// of this writing, it was generated using version 1.5.1. Go does not support
// path@version synytax with 'go run', so oapi-codegen must be installed
// manually before code can be generated:
// 'go install github.com/deepmap/oapi-codegen/cmd/oapi-codegen@1.5.1'

//go:generate oapi-codegen -generate types -package controllers -o ./types.gen.go ../../schema/api.spec.yaml
//go:generate oapi-codegen -generate server,spec -package controllers -o ./spec.gen.go ../../schema/api.spec.yaml

import (
	"config-manager/api/instrumentation"
	"config-manager/application"
	"config-manager/domain"
	"config-manager/infrastructure/persistence"
	"config-manager/utils"
	"context"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"

	"github.com/getkin/kin-openapi/openapi3"

	oapiMiddleware "github.com/deepmap/oapi-codegen/pkg/middleware"
	"github.com/labstack/echo/v4"

	"github.com/redhatinsights/platform-go-middlewares/identity"
)

// ConfigManagerController is the main component of the API module. It
// implements all the HTTP request handlers by implementing the openapi
// ServerInterface interface.
type ConfigManagerController struct {
	ConfigManagerService *application.ConfigManagerService
	Server               *echo.Echo
	URLBasePath          string
}

// Routes sets up middlewares and registers handlers for each route
func (cmc *ConfigManagerController) Routes(spec *openapi3.Swagger) {
	openapi3.DefineStringFormat("uuid", `^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$`)
	sub := cmc.Server.Group(cmc.URLBasePath)
	sub.Use(echo.WrapMiddleware(identity.EnforceIdentity))
	sub.Use(oapiMiddleware.OapiRequestValidator(spec))
	RegisterHandlers(sub, cmc)
}

// translateStatesParams transforms params into a map, preconfigured with
// default values.
func translateStatesParams(params GetStatesParams) map[string]interface{} {
	// TODO: Again I don't like this.. Come up with a better solution for validating params (middleware?)
	p := map[string]interface{}{
		"limit":   50,
		"offset":  0,
		"sort_by": "created_at:desc",
	}

	if params.Limit != nil {
		p["limit"] = int(*params.Limit)
	}
	if params.Offset != nil {
		p["offset"] = int(*params.Offset)
	}
	if params.SortBy != nil {
		p["sort_by"] = string(*params.SortBy)
	}

	return p
}

// getClients queries the Inventory service proxy all hosts known to the account
// ID extracted from the X-Rh-Identity header.
func (cmc *ConfigManagerController) getClients(ctx echo.Context) ([]domain.Host, error) {
	//TODO There's probably a better way to do this
	ctxWithID := context.WithValue(ctx.Request().Context(), persistence.IdentityKey, ctx.Request().Header["X-Rh-Identity"][0])
	var clients []domain.Host
	var err error

	res, err := cmc.ConfigManagerService.GetInventoryClients(ctxWithID, 1)
	if err != nil {
		instrumentation.InventoryRequestError()
		return nil, err
	}
	clients = append(clients, res.Results...)

	for len(clients) < res.Total {
		page := res.Page + 1
		res, err = cmc.ConfigManagerService.GetInventoryClients(ctxWithID, page)
		if err != nil {
			instrumentation.InventoryRequestError()
			return nil, err
		}
		clients = append(clients, res.Results...)
	}

	return clients, err
}

// GetStates gets the archive of state changes for the requesting account.
// It is the handler for HTTP `GET /states` requests.
func (cmc *ConfigManagerController) GetStates(ctx echo.Context, params GetStatesParams) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Println("Getting state changes for account: ", id.Identity.AccountNumber)

	p := translateStatesParams(params)

	// Add filter and sort-by
	states, err := cmc.ConfigManagerService.GetStateChanges(
		id.Identity.AccountNumber,
		p["sort_by"].(string),
		p["limit"].(int),
		p["offset"].(int),
	)
	if err != nil {
		instrumentation.GetStateChangesError()
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, states)
}

// UpdateStates updates the active configuration state for the requesting
// account, persisting it into the database before applying the state to all
// identified clients.
// It is the handler for HTTP `POST /states` requests.
func (cmc *ConfigManagerController) UpdateStates(ctx echo.Context) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Println("Updating and applying state for account: ", id.Identity.AccountNumber)

	payload := &domain.StateMap{}
	bytes, err := ioutil.ReadAll(ctx.Request().Body)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	err = json.Unmarshal(bytes, payload)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	currentState, err := cmc.ConfigManagerService.GetAccountState(id.Identity.AccountNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	equal, err := utils.VerifyStatePayload(currentState.State, *payload)
	if err != nil {
		log.Printf("Payload verification error: %s", err.Error())
		instrumentation.PayloadVerificationError()
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}
	if equal {
		log.Printf("Provided payload %+v is equal to current state %+v. Not updating\n", payload, currentState)
		return ctx.JSON(http.StatusOK, currentState)
	}

	acc, err := cmc.ConfigManagerService.UpdateAccountState(id.Identity.AccountNumber, "demo-user", *payload)
	if err != nil {
		instrumentation.UpdateAccountStateError()
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	clients, err := cmc.getClients(ctx)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	// TODO: Update ApplyState to return proper response data (dispatcher response code + id per client)

	results, err := cmc.ConfigManagerService.ApplyState(ctx.Request().Context(), acc, clients)
	if err != nil {
		instrumentation.PlaybookDispatcherRequestError()
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	log.Println("Dispatcher results: ", results)

	return ctx.JSON(http.StatusOK, acc)
}

// GetCurrentState gets the current configuration state for the requesting
// account.
// It is the handler for HTTP `GET /states/current` requests.
func (cmc *ConfigManagerController) GetCurrentState(ctx echo.Context) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Println("Getting current state for account: ", id.Identity.AccountNumber)

	acc, err := cmc.ConfigManagerService.GetAccountState(id.Identity.AccountNumber)
	if err != nil {
		instrumentation.GetAccountStateError()
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, acc)
}

// GetStateById gets a single configuration state from the state archive for the
// requesting account.
// It is the handler for HTTP `GET /states/{id}` requests.
func (cmc *ConfigManagerController) GetStateById(ctx echo.Context, stateID StateIDParam) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Printf("Getting state change for account: %s, with id: %s\n", id.Identity.AccountNumber, string(stateID))

	state, err := cmc.ConfigManagerService.GetSingleStateChange(string(stateID))
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, state)
}

// PostManage sets the value of skip_apply_state on current account state record
// for the account.
// It is the handler for HTTP `POST /manage` requests.
func (cmc *ConfigManagerController) PostManage(ctx echo.Context) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}

	data, err := ioutil.ReadAll(ctx.Request().Body)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}
	defer ctx.Request().Body.Close()

	var enabled bool
	if err := json.Unmarshal(data, &enabled); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	log.Printf("Setting apply_state for account: %v to %v\n", id.Identity.AccountNumber, !enabled)

	if err := cmc.ConfigManagerService.SetApplyState(id.Identity.AccountNumber, enabled); err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.String(http.StatusOK, "")
}

// GetPlaybookById generates a playbook constructed from the state archive
// identified by the given stateID and returns it.
// It is the handler for HTTP `GET /states/{id}/playbook` requests.
func (cmc *ConfigManagerController) GetPlaybookById(ctx echo.Context, stateID StateIDParam) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Printf("Getting playbook for account: %s, with id: %s\n", id.Identity.AccountNumber, string(stateID))

	playbook, err := cmc.ConfigManagerService.GetPlaybook(string(stateID))
	if err != nil {
		instrumentation.PlaybookRequestError()
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	instrumentation.PlaybookRequestOK()
	return ctx.String(http.StatusOK, playbook)
}

// GetPlaybookPreview generates a playbook from the data provided in the request
// body and returns it.
// It is the handler for HTTP `GET /states/preview` requests.
func (cmc *ConfigManagerController) GetPlaybookPreview(ctx echo.Context) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Printf("Getting playbook preview for account: %s\n", id.Identity.AccountNumber)

	payload := &domain.StateMap{}
	bytes, err := ioutil.ReadAll(ctx.Request().Body)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	err = json.Unmarshal(bytes, payload)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	playbook, err := cmc.ConfigManagerService.PlaybookGenerator.GeneratePlaybook(*payload)
	if err != nil {
		instrumentation.PlaybookRequestError()
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.String(http.StatusOK, playbook)
}
