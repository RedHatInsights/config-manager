package controllers

// package controllers contains code generated from the OpenAPI REST spec. This
// code is generated by the github.com/deepmap/oapi-codegen project. At the time
// of this writing, it was generated using version 1.5.1. Go does not support
// path@version synytax with 'go run', so oapi-codegen must be installed
// manually before code can be generated:
// 'go install github.com/deepmap/oapi-codegen/cmd/oapi-codegen@1.5.1'

//go:generate oapi-codegen -generate types -package controllers -o ./types.gen.go ../../schema/api.spec.yaml
//go:generate oapi-codegen -generate server,spec -package controllers -o ./spec.gen.go ../../schema/api.spec.yaml

import (
	"config-manager/api/instrumentation"
	"config-manager/application"
	"config-manager/domain"
	"config-manager/infrastructure/persistence"
	"config-manager/internal/config"
	"config-manager/internal/db"
	"config-manager/utils"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/rs/zerolog/log"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/google/uuid"

	oapiMiddleware "github.com/deepmap/oapi-codegen/pkg/middleware"
	"github.com/labstack/echo/v4"

	"github.com/redhatinsights/platform-go-middlewares/identity"
)

// ConfigManagerController is the main component of the API module. It
// implements all the HTTP request handlers by implementing the openapi
// ServerInterface interface.
type ConfigManagerController struct {
	ConfigManagerService *application.ConfigManagerService
	Server               *echo.Echo
	URLBasePath          string
}

// Routes sets up middlewares and registers handlers for each route
func (cmc *ConfigManagerController) Routes(spec *openapi3.Swagger) {
	openapi3.DefineStringFormat("uuid", `^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$`)
	sub := cmc.Server.Group(cmc.URLBasePath)
	sub.Use(echo.WrapMiddleware(identity.EnforceIdentity))
	sub.Use(oapiMiddleware.OapiRequestValidator(spec))
	RegisterHandlers(sub, cmc)
}

// getClients queries the Inventory service proxy all hosts known to the account
// ID extracted from the X-Rh-Identity header.
func (cmc *ConfigManagerController) getClients(ctx echo.Context) ([]domain.Host, error) {
	//TODO There's probably a better way to do this
	ctxWithID := context.WithValue(ctx.Request().Context(), persistence.IdentityKey, ctx.Request().Header["X-Rh-Identity"][0])
	var clients []domain.Host
	var err error

	res, err := cmc.ConfigManagerService.GetInventoryClients(ctxWithID, 1)
	if err != nil {
		instrumentation.InventoryRequestError()
		return nil, err
	}
	clients = append(clients, res.Results...)

	for len(clients) < res.Total {
		page := res.Page + 1
		res, err = cmc.ConfigManagerService.GetInventoryClients(ctxWithID, page)
		if err != nil {
			instrumentation.InventoryRequestError()
			return nil, err
		}
		clients = append(clients, res.Results...)
	}

	return clients, err
}

// GetStates gets the archive of state changes for the requesting account.
// It is the handler for HTTP `GET /states` requests.
func (cmc *ConfigManagerController) GetStates(ctx echo.Context, params GetStatesParams) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Info().Msgf("Getting state changes for account: %v", id.Identity.AccountNumber)

	var (
		sortBy string
		limit  int
		offset int
	)

	if params.SortBy != nil {
		sortBy = string(*params.SortBy)
	}

	if params.Limit != nil {
		limit = int(*params.Limit)
	}

	if params.Offset != nil {
		offset = int(*params.Offset)
	}

	total, err := db.CountProfiles(id.Identity.AccountNumber)
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err)
		log.Printf("%v", echoErr)
		return echoErr
	}

	profiles, err := db.GetProfiles(id.Identity.AccountNumber, sortBy, limit, offset)
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err)
		log.Printf("%v", echoErr)
		return echoErr
	}

	type state struct {
		AccountID string            `json:"account_id"`
		StateID   uuid.UUID         `json:"id"`
		Label     string            `json:"label"`
		Initiator string            `json:"initiator"`
		CreatedAt time.Time         `json:"created_at"`
		State     map[string]string `json:"state"`
	}

	type response struct {
		Count   int     `json:"count"`
		Limit   int     `json:"limit"`
		Offset  int     `json:"offset"`
		Total   int     `json:"total"`
		Results []state `json:"results"`
	}

	states := make([]state, 0, len(profiles))

	for _, profile := range profiles {
		s := state{
			AccountID: profile.AccountID.String,
			StateID:   profile.ID,
			Label:     profile.Label.String,
			Initiator: profile.Creator.String,
			CreatedAt: profile.CreatedAt,
			State:     make(map[string]string),
		}

		s.State = profile.StateConfig()

		states = append(states, s)
	}

	r := response{
		Count:   len(profiles),
		Limit:   limit,
		Offset:  offset,
		Total:   total,
		Results: states,
	}

	if err != nil {
		instrumentation.GetStateChangesError()
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, r)
}

// UpdateStates updates the active configuration state for the requesting
// account, persisting it into the database before applying the state to all
// identified clients.
// It is the handler for HTTP `POST /states` requests.
func (cmc *ConfigManagerController) UpdateStates(ctx echo.Context) error {
	logger := log.With().Str("method", ctx.Request().Method).Str("path", ctx.Path()).Logger()

	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		err := fmt.Errorf("unable to assert x-rh-identity header")
		logger.Error().Err(err).Msg("")
		return echo.NewHTTPError(http.StatusBadRequest, err)
	}
	logger = logger.With().Str("account_number", id.Identity.AccountNumber).Logger()

	payload := &domain.StateMap{}
	bytes, err := ioutil.ReadAll(ctx.Request().Body)
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		logger.Error().Err(echoErr).Msg("failed to read HTTP request body")
		return echoErr
	}

	err = json.Unmarshal(bytes, payload)
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		logger.Error().Err(echoErr).Msg("failed to unmarshal data")
		return echoErr
	}

	currentProfile, err := db.GetCurrentProfile(id.Identity.AccountNumber)
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		logger.Error().Err(echoErr).Msg("failed to get current profile for account")
		return echoErr
	}
	logger.Trace().Interface("currentProfile", currentProfile).Msg("found current profile")

	equal, err := utils.VerifyStatePayload(currentProfile.StateConfig(), *payload)
	if err != nil {
		instrumentation.PayloadVerificationError()
		echoErr := echo.NewHTTPError(http.StatusBadRequest, err)
		logger.Error().Err(echoErr).Msg("failed to verify payload")
		return echoErr
	}
	if equal {
		logger.Info().Interface("newState", payload).Interface("currentState", currentProfile.StateConfig()).Msg("newState = currentState")

		return ctx.JSON(http.StatusOK, formatAPIResponse(currentProfile))
	}

	newProfile := db.CopyProfile(*currentProfile)
	newProfile.SetStateConfig(*payload)
	if !newProfile.OrgID.Valid && id.Identity.OrgID != "" {
		newProfile.OrgID.String = id.Identity.OrgID
		newProfile.OrgID.Valid = true
	}
	logger.Trace().Interface("newProfile", newProfile).Msg("created new profile")

	if err := db.InsertProfile(newProfile); err != nil {
		instrumentation.UpdateAccountStateError()
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		logger.Error().Err(echoErr).Msg("failed to insert profile")
		return echoErr
	}

	clients, err := cmc.getClients(ctx)
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		logger.Error().Err(echoErr).Msg("failed to get clients")
		return echoErr
	}

	// TODO: Update ApplyState to return proper response data (dispatcher response code + id per client)

	go func() {
		results, err := cmc.ConfigManagerService.ApplyState(ctx.Request().Context(), newProfile, clients)
		if err != nil {
			instrumentation.PlaybookDispatcherRequestError()
			logger.Error().Err(err).Msg("error applying state")
		}

		logger.Info().Msgf("Dispatcher results: %v", results)
	}()

	return ctx.JSON(http.StatusOK, formatAPIResponse(&newProfile))
}

// GetCurrentState gets the current configuration state for the requesting
// account.
// It is the handler for HTTP `GET /states/current` requests.
func (cmc *ConfigManagerController) GetCurrentState(ctx echo.Context) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Info().Msgf("Getting current state for account: %v", id.Identity.AccountNumber)

	var defaultState map[string]string
	if err := json.Unmarshal([]byte(config.DefaultConfig.ServiceConfig), &defaultState); err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		log.Error().Err(echoErr)
		return echoErr
	}
	profile, err := db.GetOrInsertCurrentProfile(id.Identity.AccountNumber, db.NewProfile(id.Identity.AccountNumber, defaultState))
	if err != nil {
		instrumentation.GetAccountStateError()
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		log.Error().Err(echoErr)
		return echoErr
	}

	return ctx.JSON(http.StatusOK, formatAPIResponse(profile))
}

// GetStateById gets a single configuration state from the state archive for the
// requesting account.
// It is the handler for HTTP `GET /states/{id}` requests.
func (cmc *ConfigManagerController) GetStateById(ctx echo.Context, stateID StateIDParam) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Info().Msgf("Getting state change for account: %s, with id: %s\n", id.Identity.AccountNumber, string(stateID))

	profile, err := db.GetProfile(string(stateID))
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		log.Error().Err(echoErr)
		return echoErr
	}

	type response struct {
		Account   string            `json:"account"`
		ID        uuid.UUID         `json:"id"`
		Label     string            `json:"label"`
		Initiator string            `json:"initiator"`
		CreatedAt time.Time         `json:"created_at"`
		State     map[string]string `json:"state"`
	}

	r := response{
		Account:   profile.AccountID.String,
		ID:        profile.ID,
		Label:     profile.Label.String,
		Initiator: profile.Creator.String,
		CreatedAt: profile.CreatedAt,
		State:     profile.StateConfig(),
	}

	return ctx.JSON(http.StatusOK, r)
}

// PostManage sets the value of skip_apply_state on current account state record
// for the account.
// It is the handler for HTTP `POST /manage` requests.
func (cmc *ConfigManagerController) PostManage(ctx echo.Context) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}

	data, err := ioutil.ReadAll(ctx.Request().Body)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}
	defer ctx.Request().Body.Close()

	var enabled bool
	if err := json.Unmarshal(data, &enabled); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	log.Info().Msgf("Setting apply_state for account: %v to %v\n", id.Identity.AccountNumber, enabled)

	currentProfile, err := db.GetCurrentProfile(id.Identity.AccountNumber)
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		log.Error().Err(echoErr)
		return echoErr
	}

	newProfile := db.CopyProfile(*currentProfile)
	newProfile.Active = enabled

	if err := db.InsertProfile(newProfile); err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		log.Error().Err(echoErr)
		return echoErr
	}

	return ctx.String(http.StatusOK, "")
}

// GetPlaybookById generates a playbook constructed from the state archive
// identified by the given stateID and returns it.
// It is the handler for HTTP `GET /states/{id}/playbook` requests.
func (cmc *ConfigManagerController) GetPlaybookById(ctx echo.Context, stateID StateIDParam) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Info().Msgf("Getting playbook for account: %s, with id: %s\n", id.Identity.AccountNumber, string(stateID))

	profile, err := db.GetProfile(string(stateID))
	if err != nil {
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		log.Error().Err(echoErr)
		return echoErr
	}

	playbook, err := cmc.ConfigManagerService.PlaybookGenerator.GeneratePlaybook(profile.StateConfig())
	if err != nil {
		instrumentation.PlaybookRequestError()
		echoErr := echo.NewHTTPError(http.StatusInternalServerError, err.Error())
		log.Error().Err(echoErr)
		return echoErr
	}

	instrumentation.PlaybookRequestOK()
	return ctx.String(http.StatusOK, playbook)
}

// GetPlaybookPreview generates a playbook from the data provided in the request
// body and returns it.
// It is the handler for HTTP `GET /states/preview` requests.
func (cmc *ConfigManagerController) GetPlaybookPreview(ctx echo.Context) error {
	id, ok := ctx.Request().Context().Value(identity.Key).(identity.XRHID)
	if !ok {
		return echo.NewHTTPError(http.StatusBadRequest, "unable to assert x-rh-identity header")
	}
	log.Info().Msgf("Getting playbook preview for account: %s\n", id.Identity.AccountNumber)

	payload := &domain.StateMap{}
	bytes, err := ioutil.ReadAll(ctx.Request().Body)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	err = json.Unmarshal(bytes, payload)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	playbook, err := cmc.ConfigManagerService.PlaybookGenerator.GeneratePlaybook(*payload)
	if err != nil {
		instrumentation.PlaybookRequestError()
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.String(http.StatusOK, playbook)
}

// formatAPIResponse converts profile into an AccountState, ready to be used in
// API v1 responses.
func formatAPIResponse(profile *db.Profile) AccountState {
	var accountState AccountState

	if profile.AccountID.Valid {
		accountState.Account = (*Account)(&profile.AccountID.String)
	}

	accountState.ApplyState = (*ApplyState)(&profile.Active)

	id := profile.ID.String()
	accountState.Id = (*StateID)(&id)

	if profile.Label.Valid {
		accountState.Label = (*Label)(&profile.Label.String)
	}

	accountState.State = &State{
		Insights:           profile.StateConfig()["insights"],
		Remediations:       profile.StateConfig()["remediations"],
		ComplianceOpenscap: profile.StateConfig()["compliance_openscap"],
	}

	return accountState
}
